so at this point we're pretty familiar with all of the data type that come native to see we have characters and floats and integers and doubles and we're also familiar now with the cs fifty data types of strings and bulls but that doesn't limit everything that we can do we surely can do more indeed with structures that cause this inability to start to our own data types might be useful for our own programs what's cool about structures as they allow us to unify many different variables of different data types into a single brand new type and we can give that new type it's own unique type name as a way to identify it this isn't the first time we've seen the ability to combine multiple variables together either we've seen that with a raise remember the restriction with a raise that we can only combine things of the same type we can have a whole bunch of integers are whole bunch of floats but we can't mix them up with structures we actually can we can group together logical we can live together elements that have a logical connection to one another so for example we can group together a structure for like say a student where a student would have an id number which is probably an integer but they also have a name which is a string and they might have a g p a which is a float and we can have all of these things tied together and basically what's a super variable is a variable that has other variables within it the way to do to do this and see is actually pretty straightforward simpson text might look like this instead of a student in this example let's use a car we introduced the concept of a structure by saying struct we're about to define a structure type and in particular we're going to define a struct car and struct car actually now becomes our type name it's not just car it's struct car inside of the curly braces from this point forward we can define all of the different variables that we want inside of our super variable so for example here are some things that are common to cars they have a year either they were manufactured we have a model and a license plate and an odometer which has a number of miles and maybe they have an engine size which in the united states is usually represented as a float for how many leaders on the engine the capacity is and notice that these are all different datatypes mixed together we have integers and we have two strings and we have a float or double all mixed up inside of one super variable to finish our definition of the structure we have a closing curly brace and then really important that common syntax error is a semi colon at the end which she completes our definition of a struct car once we defined the structure and usually we defined our structure at the very top of our program up near our lb includes in our lb defines we also might define them in a separate dot h file because maybe we're using this type definition in several different files or several different programs and so it may sense to define it somewhere outside of one outside of a single file and have it be a dot h file that we can pound include in multiple different contexts now we have effectively created this new type and we can start to use it and and we can create variables of this type just like we can create variables of any other type int x that's how we create an integer called x struck the car why that's how we create a variable called y of type struct car so that's how we create the variable overall how do we create the individual fields or members of that or rather how do we access the individual fields are members of that structure we can do so using something called the dot operator let's take a look at what that looks like so the top here i have a variable declaration struct car my car again here the type is struct car and the variable name is my car from this point forward whenever i want to refer to a field or a member within my car which is again the variable name i can use the dot operator to access those individuals fields within my car so i could say for example my car dot year equals two thousand and eleven i can't just a year equals two thousand and eleven year is something that is part of my car so i have to always refer to it in the context of my car i can i can say stir copy my car dot plate cs fifty remember it's a string i can't just ask sign it i have to copy that string into the variable i can say my car dot odometer equals five o five o five or anything else that i want to do i can set the i can set the engine size and i can set the model i can do whatever else i want to do just by accessing the fields similar to this but structures like variables of all other data we don't have to just use the stack for this we don't just have to say struct car my car semicolon we could dynamically allocate this if we don't know at the beginning of our program for example that we're going to need a certain number of these things we can just declare this on the fly dynamically using pointers of course in order to access our fields in that situation we don't use just the dot operator because we have a pointer to a structure we also have to first as you may recall dereference that pointer and then access it's fields it adds a little bit of extra stuff but let's take a look again here so here now instead of statically declaring a struct car called my car i'm going to dine chemically allocate a struct car called my car so struct car star my car and then i'm going to malloc space for a struct car and here's the cool thing about size of size of is not just built in it doesn't just happen to know just the size of integers characters floats and doubles it can also figure out on the fly exactly how much space is required fired for a struct car so you don't have to go through and figure out like okay well this is probably like thirty bytes or something you can just say size of struct car and let the computer figure it out for you so struct carstar my car he calls malloc size of struct car that dynamically allocated on the heap one chunk of memory large enough to hold a single struct car within it and then i can access my fields by first d referencing the pointer and then once i've dereference the pointer i can then use the dot operator to access the fields again it's very similar to what we just saw but the syntax here is a little cumbersome right now we have extra parentheses we have this star we have this dot surely there's gotta be an easier way see pro grammar is love then it'd be easier ways to do things in fact there is a shortcut for this it so happens that accessing the field of a structure via it's pointer is a common enough operation that there is an entirely different operator that allows us to do this much more simply and is called the arrow operator which is a hyphen and then a a greater than symbol literally making it look like it's an arrow and it does two operations back to back so for the first thing it does is it d references the pointer which is on the left of the arrow and then it's going to access the field which is on the right of the arrow so for example this is what the code looked liked before this is what we just haven't said a second ago where i'm due referencing pointers and then act using the dot operator to access the fields here's what the same code would look like with the arrow syntax and the same thing is happening here the first thing i'm doing is i'm d referencing my car but the arrow operator does that for me i don't have to use the star syntax it just knows as if i have an arrow there i needed the first d reference the thing on the left and then i can access the field on the right so using the arrow operator is a great way to have a shorthand for access in the field of a structure to which you only have a pointer and you'll probably use this a fair amount so it's syntax definitely to to befriend and to get used to i'm doug lloyd this is the us fifty